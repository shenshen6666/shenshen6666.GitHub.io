<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <!-- 包含 head 部分，动态设置页面标题 -->
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>分布式搜索引擎 | 申申丫的</title>
<link rel="stylesheet" href="https://shenshen6666.GitHub.io/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <script src="https://shenshen6666.GitHub.io/media/js/page.js"></script>

    

  <!-- 页面描述信息 -->
  <meta name="description" content="分布式搜索引擎01
-- elasticsearch基础
0.学习目标
1.初识elasticsearch
1.1.了解ES
1.1.1.elasticsearch的作用
elasticsearch是一款非常强大的开源搜索引擎，具备非常多强...">
  <!-- 引入 jQuery -->
  <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
  <!-- 代码高亮库 Prism.js -->
  <script src="https://shenshen6666.GitHub.io/media/js/prism.js"></script>
  <!-- KaTeX数学公式样式 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  <!-- Gitalk评论样式 -->
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <!-- 引入 Gitalk评论功能脚本 -->
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  <!-- 页面样式 -->
  <style>
    /* 网址模块样式 */
    .zhihu-iframe {
      position: fixed;
      top: 5px; /* 初始状态悬浮在页面上方 */
      left: 75%; /* 距离左边界75%的位置 */
      transform: translateX(-50%);
      z-index: 999;
      display: none; /* 初始状态隐藏网址模块 */
    }

    /* 按钮样式 */
    #toggleButton, #moveUpButton, #moveDownButton {
      cursor: pointer;
      position: fixed;
      bottom: 20px;
      right: 50px; /* 按钮距离右边界50px的位置 */
      padding: 10px;
      background-color: transparent;
      color: #000000;
      border: none;
      border-radius: 5px;
      margin: 5px;
    }

    /* 修复按钮样式 */
    #moveUpButton, #moveDownButton {
      bottom: 70px; /* 上移、下移按钮的位置 */
    }

    #moveDownButton {
      bottom: 120px; /* 下移按钮的位置 */
    }
  </style>
</head>
<body>
  <div class="antialiased">
    <div class="body-width mx-auto px-6 md:px-8">
      <!-- 包含页面头部 -->
      
<div class="flex justify-between items-center mt-10">
  <h1 class="text-lg sm:text-xl md:text-2xl lg:text-3xl text-gray-900 font-medium md:font-normal leading-none">
    <div class="glitch-wrapper">
      <div class="glitch" data-text="申申丫的">
        <a href="https://shenshen6666.GitHub.io">申申丫的</a>
      </div>
    </div>
  </h1>
  <div class="block lg:hidden" id="thumb-menu">
    <button id="thumb-open" type="button" class="block">
      <i class="icon icon-menu-close"></i>
    </button>
    <button id="thumb-close" type="button" class="hidden">
      <i class="icon icon-menu-open"></i>
    </button>
  </div>
</div>
<div id="nav-list" class="lg:block hidden">
  <div class="w-full block lg:flex lg:justify-between border-external-bottom lg:border-gray-400 mt-10 text-gray-700 lg:text-lg">
    <div class="lg:flex -mb-px">
      
        
          <div class="pb-4">
            <a href="/" class="nav-link">
              <i class="icon icon-home"></i> 
              首页
            </a>
          </div>
        
      
        
          <div class="pb-4">
            <a href="/archives" class="nav-link">
              <i class="icon icon-archive"></i> 
              归档
            </a>
          </div>
        
      
        
          <div class="pb-4">
            <a href="/tags" class="nav-link">
              <i class="icon icon-tags"></i> 
              标签
            </a>
          </div>
        
      
        
          <div class="pb-4">
            <a href="/post/about" class="nav-link">
              <i class="icon icon-user"></i> 
              关于
            </a>
          </div>
        
      
        
          <div class="pb-4">
            <a href="/essays" class="nav-link">
              <i class="icon icon-"></i> 
              测试菜单
            </a>
          </div>
        
      
      <div class="search-frame pb-4">
        <i class="icon icon-search"></i>
        <form id="search-form" action="https://shenshen6666.GitHub.io/search/">
          <input name="searchContent" type="text" placeholder="Search..." />
        </form>
      </div>
    </div>
    <div class="lg:flex">
      <ul>
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
      <a href="https://shenshen6666.GitHub.io/atom.xml" class="block mt-4 lg:mt-0 lg:ml-8 align-center hover:text-gray-900" target="_blank">
        <i class="icon icon-rss"></i>
        RSS
      </a>
    </div>
  </div>
</div>
      <!-- 页面主体 -->
      <div class="mb-20 md:flex mt-10 lg:mt-6 md:border-internal md:border-gray-400 md:pt-2 lg:border-t-0 lg:pt-0">
        <!-- 左侧内容 -->
        <div class="w-full md:w-2/3 mt-6">
          <!-- 文章标题 -->
          <h1 class="post-title text-3xl">分布式搜索引擎</h1>
          <!-- 如果有特色图片，则显示 -->
          
          <!-- 文章内容 -->
          <div class="mt-6 lg:mt-10 post-content">
            <h1 id="分布式搜索引擎01">分布式搜索引擎01</h1>
<p>-- elasticsearch基础</p>
<h1 id="0学习目标">0.学习目标</h1>
<h1 id="1初识elasticsearch">1.初识elasticsearch</h1>
<h2 id="11了解es">1.1.了解ES</h2>
<h3 id="111elasticsearch的作用">1.1.1.elasticsearch的作用</h3>
<p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p>
<p>例如：</p>
<ul>
<li>
<p>在GitHub搜索代码</p>
<figure data-type="image" tabindex="1"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720193623245.png" alt="image-20210720193623245" loading="lazy"></figure>
</li>
<li>
<p>在电商网站搜索商品</p>
<figure data-type="image" tabindex="2"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720193633483.png" alt="image-20210720193633483" loading="lazy"></figure>
</li>
<li>
<p>在百度搜索答案</p>
<figure data-type="image" tabindex="3"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720193641907.png" alt="image-20210720193641907" loading="lazy"></figure>
</li>
<li>
<p>在打车软件搜索附近的车</p>
<figure data-type="image" tabindex="4"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720193648044.png" alt="image-20210720193648044" loading="lazy"></figure>
</li>
</ul>
<h3 id="112elk技术栈">1.1.2.ELK技术栈</h3>
<p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p>
<figure data-type="image" tabindex="5"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720194008781.png" alt="image-20210720194008781" loading="lazy"></figure>
<p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p>
<figure data-type="image" tabindex="6"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720194230265.png" alt="image-20210720194230265" loading="lazy"></figure>
<h3 id="113elasticsearch和lucene">1.1.3.elasticsearch和lucene</h3>
<p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p>
<p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：https://lucene.apache.org/ 。</p>
<figure data-type="image" tabindex="7"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720194547780.png" alt="image-20210720194547780" loading="lazy"></figure>
<p><strong>elasticsearch</strong>的发展历史：</p>
<ul>
<li>2004年Shay Banon基于Lucene开发了Compass</li>
<li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720195001221.png" alt="image-20210720195001221" loading="lazy"></figure>
<h3 id="114为什么不是其他搜索技术">1.1.4.为什么不是其他搜索技术？</h3>
<p>目前比较知名的搜索引擎技术排名：</p>
<figure data-type="image" tabindex="9"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720195142535.png" alt="image-20210720195142535" loading="lazy"></figure>
<p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p>
<figure data-type="image" tabindex="10"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720195306484.png" alt="image-20210720195306484" loading="lazy"></figure>
<h3 id="115总结">1.1.5.总结</h3>
<p>什么是elasticsearch？</p>
<ul>
<li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li>
</ul>
<p>什么是elastic stack（ELK）？</p>
<ul>
<li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li>
</ul>
<p>什么是Lucene？</p>
<ul>
<li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li>
</ul>
<h2 id="12倒排索引">1.2.倒排索引</h2>
<p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p>
<h3 id="121正向索引">1.2.1.正向索引</h3>
<p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p>
<figure data-type="image" tabindex="11"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720195531539.png" alt="image-20210720195531539" loading="lazy"></figure>
<p>如果是根据id查询，那么直接走索引，查询速度非常快。</p>
<p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p>
<p>1）用户搜索数据，条件是title符合<code>&quot;%手机%&quot;</code></p>
<p>2）逐行获取数据，比如id为1的数据</p>
<p>3）判断数据中的title是否符合用户搜索条件</p>
<p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p>
<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p>
<h3 id="122倒排索引">1.2.2.倒排索引</h3>
<p>倒排索引中有两个非常重要的概念：</p>
<ul>
<li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li>
</ul>
<p>如图：</p>
<figure data-type="image" tabindex="12"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720200457207.png" alt="image-20210720200457207" loading="lazy"></figure>
<p>倒排索引的<strong>搜索流程</strong>如下（以搜索&quot;华为手机&quot;为例）：</p>
<p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p>
<p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p>
<p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p>
<p>4）拿着文档id到正向索引中查找具体文档。</p>
<p>如图：</p>
<figure data-type="image" tabindex="13"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720201115192.png" alt="image-20210720201115192" loading="lazy"></figure>
<p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p>
<h3 id="123正向和倒排">1.2.3.正向和倒排</h3>
<p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p>
<ul>
<li>
<p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p>
</li>
<li>
<p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p>
</li>
</ul>
<p>是不是恰好反过来了？</p>
<p>那么两者方式的优缺点是什么呢？</p>
<p><strong>正向索引</strong>：</p>
<ul>
<li>优点：
<ul>
<li>可以给多个字段创建索引</li>
<li>根据索引字段搜索、排序速度非常快</li>
</ul>
</li>
<li>缺点：
<ul>
<li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li>
</ul>
</li>
</ul>
<p><strong>倒排索引</strong>：</p>
<ul>
<li>优点：
<ul>
<li>根据词条搜索、模糊搜索时，速度非常快</li>
</ul>
</li>
<li>缺点：
<ul>
<li>只能给词条创建索引，而不是字段</li>
<li>无法根据字段做排序</li>
</ul>
</li>
</ul>
<h2 id="13es的一些概念">1.3.es的一些概念</h2>
<p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p>
<h3 id="131文档和字段">1.3.1.文档和字段</h3>
<p>elasticsearch是面向**文档（Document）**存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p>
<figure data-type="image" tabindex="14"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720202707797.png" alt="image-20210720202707797" loading="lazy"></figure>
<p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p>
<h3 id="132索引和映射">1.3.2.索引和映射</h3>
<p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720203022172.png" alt="image-20210720203022172" loading="lazy"></figure>
<p>因此，我们可以把索引当做是数据库中的表。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p>
<h3 id="133mysql与elasticsearch">1.3.3.mysql与elasticsearch</h3>
<p>我们统一的把mysql与elasticsearch的概念做一下对比：</p>
<table>
<thead>
<tr>
<th><strong>MySQL</strong></th>
<th><strong>Elasticsearch</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Table</td>
<td>Index</td>
<td>索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
<td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td>SQL</td>
<td>DSL</td>
<td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody>
</table>
<p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p>
<p>并不是如此，两者各自有自己的擅长支出：</p>
<ul>
<li>
<p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p>
</li>
<li>
<p>Elasticsearch：擅长海量数据的搜索、分析、计算</p>
</li>
</ul>
<p>因此在企业中，往往是两者结合使用：</p>
<ul>
<li>对安全性要求较高的写操作，使用mysql实现</li>
<li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li>
<li>两者再基于某种方式，实现数据的同步，保证一致性</li>
</ul>
<figure data-type="image" tabindex="16"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720203534945.png" alt="image-20210720203534945" loading="lazy"></figure>
<h2 id="14安装es-kibana">1.4.安装es、kibana</h2>
<h3 id="141安装">1.4.1.安装</h3>
<p>参考课前资料：</p>
<figure data-type="image" tabindex="17"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720203805350.png" alt="image-20210720203805350" loading="lazy"></figure>
<h3 id="142分词器">1.4.2.分词器</h3>
<p>参考课前资料：</p>
<figure data-type="image" tabindex="18"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720203805350.png" alt="image-20210720203805350" loading="lazy"></figure>
<h3 id="143总结">1.4.3.总结</h3>
<p>分词器的作用是什么？</p>
<ul>
<li>创建倒排索引时对文档分词</li>
<li>用户搜索时，对输入的内容分词</li>
</ul>
<p>IK分词器有几种模式？</p>
<ul>
<li>ik_smart：智能切分，粗粒度</li>
<li>ik_max_word：最细切分，细粒度</li>
</ul>
<p>IK分词器如何拓展词条？如何停用词条？</p>
<ul>
<li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li>
<li>在词典中添加拓展词条或者停用词条</li>
</ul>
<h1 id="2索引库操作">2.索引库操作</h1>
<p>索引库就类似数据库表，mapping映射就类似表的结构。</p>
<p>我们要向es中存储数据，必须先创建“库”和“表”。</p>
<h2 id="21mapping映射属性">2.1.mapping映射属性</h2>
<p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：
<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float、</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li>index：是否创建索引，默认为true</li>
<li>analyzer：使用哪种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<p>例如下面的json文档：</p>
<pre><code class="language-json">{
    &quot;age&quot;: 21,
    &quot;weight&quot;: 52.1,
    &quot;isMarried&quot;: false,
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;score&quot;: [99.1, 99.5, 98.9],
    &quot;name&quot;: {
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    }
}
</code></pre>
<p>对应的每个字段映射（mapping）：</p>
<ul>
<li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li>
<li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li>
<li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li>
<li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li>
<li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li>
<li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li>
<li>name：类型为object，需要定义多个子属性
<ul>
<li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li>
<li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li>
</ul>
</li>
</ul>
<h2 id="22索引库的crud">2.2.索引库的CRUD</h2>
<p>这里我们统一使用Kibana编写DSL的方式来演示。</p>
<h3 id="221创建索引库和映射">2.2.1.创建索引库和映射</h3>
<h4 id="基本语法">基本语法：</h4>
<ul>
<li>请求方式：PUT</li>
<li>请求路径：/索引库名，可以自定义</li>
<li>请求参数：mapping映射</li>
</ul>
<p>格式：</p>
<pre><code class="language-json">PUT /索引库名称
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;字段名&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      },
      &quot;字段名2&quot;:{
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;false&quot;
      },
      &quot;字段名3&quot;:{
        &quot;properties&quot;: {
          &quot;子字段&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          }
        }
      },
      // ...略
    }
  }
}
</code></pre>
<h4 id="示例">示例：</h4>
<pre><code class="language-sh">PUT /heima
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;info&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      },
      &quot;email&quot;:{
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;falsae&quot;
      },
      &quot;name&quot;:{
        &quot;properties&quot;: {
          &quot;firstName&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          }
        }
      },
      // ... 略
    }
  }
}
</code></pre>
<h3 id="222查询索引库">2.2.2.查询索引库</h3>
<p><strong>基本语法</strong>：</p>
<ul>
<li>
<p>请求方式：GET</p>
</li>
<li>
<p>请求路径：/索引库名</p>
</li>
<li>
<p>请求参数：无</p>
</li>
</ul>
<p><strong>格式</strong>：</p>
<pre><code>GET /索引库名
</code></pre>
<p><strong>示例</strong>：</p>
<figure data-type="image" tabindex="19"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720211019329.png" alt="image-20210720211019329" loading="lazy"></figure>
<h3 id="223修改索引库">2.2.3.修改索引库</h3>
<p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p>
<p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p>
<p><strong>语法说明</strong>：</p>
<pre><code class="language-json">PUT /索引库名/_mapping
{
  &quot;properties&quot;: {
    &quot;新字段名&quot;:{
      &quot;type&quot;: &quot;integer&quot;
    }
  }
}
</code></pre>
<p><strong>示例</strong>：</p>
<figure data-type="image" tabindex="20"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720212357390.png" alt="image-20210720212357390" loading="lazy"></figure>
<h3 id="224删除索引库">2.2.4.删除索引库</h3>
<p><strong>语法：</strong></p>
<ul>
<li>
<p>请求方式：DELETE</p>
</li>
<li>
<p>请求路径：/索引库名</p>
</li>
<li>
<p>请求参数：无</p>
</li>
</ul>
<p><strong>格式：</strong></p>
<pre><code>DELETE /索引库名
</code></pre>
<p>在kibana中测试：</p>
<figure data-type="image" tabindex="21"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720212123420.png" alt="image-20210720212123420" loading="lazy"></figure>
<h3 id="225总结">2.2.5.总结</h3>
<p>索引库操作有哪些？</p>
<ul>
<li>创建索引库：PUT /索引库名</li>
<li>查询索引库：GET /索引库名</li>
<li>删除索引库：DELETE /索引库名</li>
<li>添加字段：PUT /索引库名/_mapping</li>
</ul>
<h1 id="3文档操作">3.文档操作</h1>
<h2 id="31新增文档">3.1.新增文档</h2>
<p><strong>语法：</strong></p>
<pre><code class="language-json">POST /索引库名/_doc/文档id
{
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    &quot;字段3&quot;: {
        &quot;子属性1&quot;: &quot;值3&quot;,
        &quot;子属性2&quot;: &quot;值4&quot;
    },
    // ...
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-json">POST /heima/_doc/1
{
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: {
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    }
}
</code></pre>
<p><strong>响应：</strong></p>
<figure data-type="image" tabindex="22"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720212933362.png" alt="image-20210720212933362" loading="lazy"></figure>
<h2 id="32查询文档">3.2.查询文档</h2>
<p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-json">GET /{索引库名称}/_doc/{id}
</code></pre>
<p><strong>通过kibana查看数据：</strong></p>
<pre><code class="language-js">GET /heima/_doc/1
</code></pre>
<p><strong>查看结果：</strong></p>
<figure data-type="image" tabindex="23"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720213345003.png" alt="image-20210720213345003" loading="lazy"></figure>
<h2 id="33删除文档">3.3.删除文档</h2>
<p>删除使用DELETE请求，同样，需要根据id进行删除：</p>
<p><strong>语法：</strong></p>
<pre><code class="language-js">DELETE /{索引库名}/_doc/id值
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-json"># 根据id删除数据
DELETE /heima/_doc/1
</code></pre>
<p><strong>结果：</strong></p>
<figure data-type="image" tabindex="24"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720213634918.png" alt="image-20210720213634918" loading="lazy"></figure>
<h2 id="34修改文档">3.4.修改文档</h2>
<p>修改有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<h3 id="341全量修改">3.4.1.全量修改</h3>
<p>全量修改是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的id删除文档</li>
<li>新增一个相同id的文档</li>
</ul>
<p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-json">PUT /{索引库名}/_doc/文档id
{
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    // ... 略
}

</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-json">PUT /heima/_doc/1
{
    &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: {
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    }
}
</code></pre>
<h3 id="342增量修改">3.4.2.增量修改</h3>
<p>增量修改是只修改指定id匹配的文档中的部分字段。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-json">POST /{索引库名}/_update/文档id
{
    &quot;doc&quot;: {
         &quot;字段名&quot;: &quot;新的值&quot;,
    }
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-json">POST /heima/_update/1
{
  &quot;doc&quot;: {
    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;
  }
}
</code></pre>
<h2 id="35总结">3.5.总结</h2>
<p>文档操作有哪些？</p>
<ul>
<li>创建文档：POST /{索引库名}/_doc/文档id   { json文档 }</li>
<li>查询文档：GET /{索引库名}/_doc/文档id</li>
<li>删除文档：DELETE /{索引库名}/_doc/文档id</li>
<li>修改文档：
<ul>
<li>全量修改：PUT /{索引库名}/_doc/文档id { json文档 }</li>
<li>增量修改：POST /{索引库名}/_update/文档id { &quot;doc&quot;: {字段}}</li>
</ul>
</li>
</ul>
<h1 id="4restapi">4.RestAPI</h1>
<p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html</p>
<p>其中的Java Rest Client又包括两种：</p>
<ul>
<li>Java Low Level Rest Client</li>
<li>Java High Level Rest Client</li>
</ul>
<figure data-type="image" tabindex="25"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720214555863.png" alt="image-20210720214555863" loading="lazy"></figure>
<p>我们学习的是Java HighLevel Rest Client客户端API</p>
<h2 id="40导入demo工程">4.0.导入Demo工程</h2>
<h3 id="401导入数据">4.0.1.导入数据</h3>
<p>首先导入课前资料提供的数据库数据：</p>
<figure data-type="image" tabindex="26"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720220400297.png" alt="image-20210720220400297" loading="lazy"></figure>
<p>数据结构如下：</p>
<pre><code class="language-sql">CREATE TABLE `tb_hotel` (
  `id` bigint(20) NOT NULL COMMENT '酒店id',
  `name` varchar(255) NOT NULL COMMENT '酒店名称；例：7天酒店',
  `address` varchar(255) NOT NULL COMMENT '酒店地址；例：航头路',
  `price` int(10) NOT NULL COMMENT '酒店价格；例：329',
  `score` int(2) NOT NULL COMMENT '酒店评分；例：45，就是4.5分',
  `brand` varchar(32) NOT NULL COMMENT '酒店品牌；例：如家',
  `city` varchar(32) NOT NULL COMMENT '所在城市；例：上海',
  `star_name` varchar(16) DEFAULT NULL COMMENT '酒店星级，从低到高分别是：1星到5星，1钻到5钻',
  `business` varchar(255) DEFAULT NULL COMMENT '商圈；例：虹桥',
  `latitude` varchar(32) NOT NULL COMMENT '纬度；例：31.2497',
  `longitude` varchar(32) NOT NULL COMMENT '经度；例：120.3925',
  `pic` varchar(255) DEFAULT NULL COMMENT '酒店图片；例:/img/1.jpg',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

</code></pre>
<h3 id="402导入项目">4.0.2.导入项目</h3>
<p>然后导入课前资料提供的项目:</p>
<figure data-type="image" tabindex="27"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720220503411.png" alt="image-20210720220503411" loading="lazy"></figure>
<p>项目结构如图：</p>
<figure data-type="image" tabindex="28"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720220647541.png" alt="image-20210720220647541" loading="lazy"></figure>
<h3 id="403mapping映射分析">4.0.3.mapping映射分析</h3>
<p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p>
<ul>
<li>字段名</li>
<li>字段数据类型</li>
<li>是否参与搜索</li>
<li>是否需要分词</li>
<li>如果分词，分词器是什么？</li>
</ul>
<p>其中：</p>
<ul>
<li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li>
<li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>
<li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li>
<li>分词器，我们可以统一使用ik_max_word</li>
</ul>
<p>来看下酒店数据的索引库结构:</p>
<pre><code class="language-json">PUT /hotel
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;id&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;name&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;copy_to&quot;: &quot;all&quot;
      },
      &quot;address&quot;:{
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      },
      &quot;price&quot;:{
        &quot;type&quot;: &quot;integer&quot;
      },
      &quot;score&quot;:{
        &quot;type&quot;: &quot;integer&quot;
      },
      &quot;brand&quot;:{
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;copy_to&quot;: &quot;all&quot;
      },
      &quot;city&quot;:{
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;copy_to&quot;: &quot;all&quot;
      },
      &quot;starName&quot;:{
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;business&quot;:{
        &quot;type&quot;: &quot;keyword&quot;
      },
      &quot;location&quot;:{
        &quot;type&quot;: &quot;geo_point&quot;
      },
      &quot;pic&quot;:{
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      },
      &quot;all&quot;:{
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      }
    }
  }
}

</code></pre>
<p>几个特殊字段说明：</p>
<ul>
<li>location：地理坐标，里面包含精度、纬度</li>
<li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li>
</ul>
<p>地理坐标说明：</p>
<figure data-type="image" tabindex="29"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720222110126.png" alt="image-20210720222110126" loading="lazy"></figure>
<p>copy_to说明：</p>
<figure data-type="image" tabindex="30"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720222221516.png" alt="image-20210720222221516" loading="lazy"></figure>
<h3 id="404初始化restclient">4.0.4.初始化RestClient</h3>
<p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p>
<p>分为三步：</p>
<p>1）引入es的RestHighLevelClient依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;
&lt;/properties&gt;

</code></pre>
<p>3）初始化RestHighLevelClient：</p>
<p>初始化的代码如下：</p>
<pre><code class="language-java">RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(
        HttpHost.create(&quot;http://192.168.150.101:9200&quot;)
));

</code></pre>
<p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p>
<pre><code class="language-java">package cn.itcast.hotel;

import org.apache.http.HttpHost;
import org.elasticsearch.client.RestHighLevelClient;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;

public class HotelIndexTest {
    private RestHighLevelClient client;

    @BeforeEach
    void setUp() {
        this.client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create(&quot;http://192.168.150.101:9200&quot;)
        ));
    }

    @AfterEach
    void tearDown() throws IOException {
        this.client.close();
    }
}

</code></pre>
<h2 id="41创建索引库">4.1.创建索引库</h2>
<h3 id="411代码解读">4.1.1.代码解读</h3>
<p>创建索引库的API如下：</p>
<figure data-type="image" tabindex="31"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720223049408.png" alt="image-20210720223049408" loading="lazy"></figure>
<p>代码分为三步：</p>
<ul>
<li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li>
<li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li>
<li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li>
</ul>
<h3 id="412完整示例">4.1.2.完整示例</h3>
<p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p>
<pre><code class="language-java">package cn.itcast.hotel.constants;

public class HotelConstants {
    public static final String MAPPING_TEMPLATE = &quot;{\n&quot; +
            &quot;  \&quot;mappings\&quot;: {\n&quot; +
            &quot;    \&quot;properties\&quot;: {\n&quot; +
            &quot;      \&quot;id\&quot;: {\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;name\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot; +
            &quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot; +
            &quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;address\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;index\&quot;: false\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;price\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;score\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;brand\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;city\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;starName\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;business\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;location\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;pic\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot; +
            &quot;        \&quot;index\&quot;: false\n&quot; +
            &quot;      },\n&quot; +
            &quot;      \&quot;all\&quot;:{\n&quot; +
            &quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot; +
            &quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot; +
            &quot;      }\n&quot; +
            &quot;    }\n&quot; +
            &quot;  }\n&quot; +
            &quot;}&quot;;
}

</code></pre>
<p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p>
<pre><code class="language-java">@Test
void createHotelIndex() throws IOException {
    // 1.创建Request对象
    CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;);
    // 2.准备请求的参数：DSL语句
    request.source(MAPPING_TEMPLATE, XContentType.JSON);
    // 3.发送请求
    client.indices().create(request, RequestOptions.DEFAULT);
}

</code></pre>
<h2 id="42删除索引库">4.2.删除索引库</h2>
<p>删除索引库的DSL语句非常简单：</p>
<pre><code class="language-json">DELETE /hotel

</code></pre>
<p>与创建索引库相比：</p>
<ul>
<li>请求方式从PUT变为DELTE</li>
<li>请求路径不变</li>
<li>无请求参数</li>
</ul>
<p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p>
<ul>
<li>1）创建Request对象。这次是DeleteIndexRequest对象</li>
<li>2）准备参数。这里是无参</li>
<li>3）发送请求。改用delete方法</li>
</ul>
<p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p>
<pre><code class="language-java">@Test
void testDeleteHotelIndex() throws IOException {
    // 1.创建Request对象
    DeleteIndexRequest request = new DeleteIndexRequest(&quot;hotel&quot;);
    // 2.发送请求
    client.indices().delete(request, RequestOptions.DEFAULT);
}

</code></pre>
<h2 id="43判断索引库是否存在">4.3.判断索引库是否存在</h2>
<p>判断索引库是否存在，本质就是查询，对应的DSL是：</p>
<pre><code class="language-json">GET /hotel

</code></pre>
<p>因此与删除的Java代码流程是类似的。依然是三步走：</p>
<ul>
<li>1）创建Request对象。这次是GetIndexRequest对象</li>
<li>2）准备参数。这里是无参</li>
<li>3）发送请求。改用exists方法</li>
</ul>
<pre><code class="language-java">@Test
void testExistsHotelIndex() throws IOException {
    // 1.创建Request对象
    GetIndexRequest request = new GetIndexRequest(&quot;hotel&quot;);
    // 2.发送请求
    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);
    // 3.输出
    System.err.println(exists ? &quot;索引库已经存在！&quot; : &quot;索引库不存在！&quot;);
}

</code></pre>
<h2 id="44总结">4.4.总结</h2>
<p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p>
<p>索引库操作的基本步骤：</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxIndexRequest。XXX是Create、Get、Delete</li>
<li>准备DSL（ Create时需要，其它是无参）</li>
<li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li>
</ul>
<h1 id="5restclient操作文档">5.RestClient操作文档</h1>
<p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li>
</ul>
<pre><code class="language-java">package cn.itcast.hotel;

import cn.itcast.hotel.pojo.Hotel;
import cn.itcast.hotel.service.IHotelService;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;
import java.util.List;

@SpringBootTest
public class HotelDocumentTest {
    @Autowired
    private IHotelService hotelService;

    private RestHighLevelClient client;

    @BeforeEach
    void setUp() {
        this.client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create(&quot;http://192.168.150.101:9200&quot;)
        ));
    }

    @AfterEach
    void tearDown() throws IOException {
        this.client.close();
    }
}


</code></pre>
<h2 id="51新增文档">5.1.新增文档</h2>
<p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p>
<h3 id="511索引库实体类">5.1.1.索引库实体类</h3>
<p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p>
<pre><code class="language-java">@Data
@TableName(&quot;tb_hotel&quot;)
public class Hotel {
    @TableId(type = IdType.INPUT)
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String longitude;
    private String latitude;
    private String pic;
}

</code></pre>
<p>与我们的索引库结构存在差异：</p>
<ul>
<li>longitude和latitude需要合并为location</li>
</ul>
<p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p>
<pre><code class="language-java">package cn.itcast.hotel.pojo;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class HotelDoc {
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String location;
    private String pic;

    public HotelDoc(Hotel hotel) {
        this.id = hotel.getId();
        this.name = hotel.getName();
        this.address = hotel.getAddress();
        this.price = hotel.getPrice();
        this.score = hotel.getScore();
        this.brand = hotel.getBrand();
        this.city = hotel.getCity();
        this.starName = hotel.getStarName();
        this.business = hotel.getBusiness();
        this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude();
        this.pic = hotel.getPic();
    }
}


</code></pre>
<h3 id="512语法说明">5.1.2.语法说明</h3>
<p>新增文档的DSL语句如下：</p>
<pre><code class="language-json">POST /{索引库名}/_doc/1
{
    &quot;name&quot;: &quot;Jack&quot;,
    &quot;age&quot;: 21
}

</code></pre>
<p>对应的java代码如图：</p>
<figure data-type="image" tabindex="32"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720230027240.png" alt="image-20210720230027240" loading="lazy"></figure>
<p>可以看到与创建索引库类似，同样是三步走：</p>
<ul>
<li>1）创建Request对象</li>
<li>2）准备请求参数，也就是DSL中的JSON文档</li>
<li>3）发送请求</li>
</ul>
<p>变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。</p>
<h3 id="513完整代码">5.1.3.完整代码</h3>
<p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p>
<ul>
<li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li>
<li>hotel对象需要转为HotelDoc对象</li>
<li>HotelDoc需要序列化为json格式</li>
</ul>
<p>因此，代码整体步骤如下：</p>
<ul>
<li>1）根据id查询酒店数据Hotel</li>
<li>2）将Hotel封装为HotelDoc</li>
<li>3）将HotelDoc序列化为JSON</li>
<li>4）创建IndexRequest，指定索引库名和id</li>
<li>5）准备请求参数，也就是JSON文档</li>
<li>6）发送请求</li>
</ul>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="language-java">@Test
void testAddDocument() throws IOException {
    // 1.根据id查询酒店数据
    Hotel hotel = hotelService.getById(61083L);
    // 2.转换为文档类型
    HotelDoc hotelDoc = new HotelDoc(hotel);
    // 3.将HotelDoc转json
    String json = JSON.toJSONString(hotelDoc);

    // 1.准备Request对象
    IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotelDoc.getId().toString());
    // 2.准备Json文档
    request.source(json, XContentType.JSON);
    // 3.发送请求
    client.index(request, RequestOptions.DEFAULT);
}

</code></pre>
<h2 id="52查询文档">5.2.查询文档</h2>
<h3 id="521语法说明">5.2.1.语法说明</h3>
<p>查询的DSL语句如下：</p>
<pre><code class="language-json">GET /hotel/_doc/{id}

</code></pre>
<p>非常简单，因此代码大概分两步：</p>
<ul>
<li>准备Request对象</li>
<li>发送请求</li>
</ul>
<p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p>
<figure data-type="image" tabindex="33"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720230811674.png" alt="image-20210720230811674" loading="lazy"></figure>
<p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p>
<p>与之前类似，也是三步走：</p>
<ul>
<li>1）准备Request对象。这次是查询，所以是GetRequest</li>
<li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li>
<li>3）解析结果，就是对JSON做反序列化</li>
</ul>
<h3 id="522完整代码">5.2.2.完整代码</h3>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="language-java">@Test
void testGetDocumentById() throws IOException {
    // 1.准备Request
    GetRequest request = new GetRequest(&quot;hotel&quot;, &quot;61082&quot;);
    // 2.发送请求，得到响应
    GetResponse response = client.get(request, RequestOptions.DEFAULT);
    // 3.解析响应结果
    String json = response.getSourceAsString();

    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
    System.out.println(hotelDoc);
}

</code></pre>
<h2 id="53删除文档">5.3.删除文档</h2>
<p>删除的DSL为是这样的：</p>
<pre><code class="language-json">DELETE /hotel/_doc/{id}

</code></pre>
<p>与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：</p>
<ul>
<li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li>
<li>2）准备参数，无参</li>
<li>3）发送请求。因为是删除，所以是client.delete()方法</li>
</ul>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="language-java">@Test
void testDeleteDocument() throws IOException {
    // 1.准备Request
    DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, &quot;61083&quot;);
    // 2.发送请求
    client.delete(request, RequestOptions.DEFAULT);
}

</code></pre>
<h2 id="54修改文档">5.4.修改文档</h2>
<h3 id="541语法说明">5.4.1.语法说明</h3>
<p>修改我们讲过两种方式：</p>
<ul>
<li>全量修改：本质是先根据id删除，再新增</li>
<li>增量修改：修改文档中的指定字段值</li>
</ul>
<p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p>这里不再赘述，我们主要关注增量修改。</p>
<p>代码示例如图：</p>
<figure data-type="image" tabindex="34"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720231040875.png" alt="image-20210720231040875" loading="lazy"></figure>
<p>与之前类似，也是三步走：</p>
<ul>
<li>1）准备Request对象。这次是修改，所以是UpdateRequest</li>
<li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li>
<li>3）更新文档。这里调用client.update()方法</li>
</ul>
<h3 id="542完整代码">5.4.2.完整代码</h3>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="language-java">@Test
void testUpdateDocument() throws IOException {
    // 1.准备Request
    UpdateRequest request = new UpdateRequest(&quot;hotel&quot;, &quot;61083&quot;);
    // 2.准备请求参数
    request.doc(
        &quot;price&quot;, &quot;952&quot;,
        &quot;starName&quot;, &quot;四钻&quot;
    );
    // 3.发送请求
    client.update(request, RequestOptions.DEFAULT);
}

</code></pre>
<h2 id="55批量导入文档">5.5.批量导入文档</h2>
<p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p>
<p>步骤如下：</p>
<ul>
<li>
<p>利用mybatis-plus查询酒店数据</p>
</li>
<li>
<p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p>
</li>
<li>
<p>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</p>
</li>
</ul>
<h3 id="551语法说明">5.5.1.语法说明</h3>
<p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p>
<p>其中提供了一个add方法，用来添加其他请求：</p>
<figure data-type="image" tabindex="35"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720232105943.png" alt="image-20210720232105943" loading="lazy"></figure>
<p>可以看到，能添加的请求包括：</p>
<ul>
<li>IndexRequest，也就是新增</li>
<li>UpdateRequest，也就是修改</li>
<li>DeleteRequest，也就是删除</li>
</ul>
<p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p>
<figure data-type="image" tabindex="36"><img src="https://shenshen6666.GitHub.io/post-images/image-20210720232431383.png" alt="image-20210720232431383" loading="lazy"></figure>
<p>其实还是三步走：</p>
<ul>
<li>1）创建Request对象。这里是BulkRequest</li>
<li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li>
<li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li>
</ul>
<p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p>
<h3 id="552完整代码">5.5.2.完整代码</h3>
<p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p>
<pre><code class="language-java">@Test
void testBulkRequest() throws IOException {
    // 批量查询酒店数据
    List&lt;Hotel&gt; hotels = hotelService.list();

    // 1.创建Request
    BulkRequest request = new BulkRequest();
    // 2.准备参数，添加多个新增的Request
    for (Hotel hotel : hotels) {
        // 2.1.转换为文档类型HotelDoc
        HotelDoc hotelDoc = new HotelDoc(hotel);
        // 2.2.创建新增文档的Request对象
        request.add(new IndexRequest(&quot;hotel&quot;)
                    .id(hotelDoc.getId().toString())
                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));
    }
    // 3.发送请求
    client.bulk(request, RequestOptions.DEFAULT);
}

</code></pre>
<h2 id="56小结">5.6.小结</h2>
<p>文档操作的基本步骤：</p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li>
<li>准备参数（Index、Update、Bulk时需要）</li>
<li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li>
<li>解析结果（Get时需要）</li>
</ul>

          </div>
        </div>
        <!-- 右侧内容 -->
        <div class="w-full md:w-1/3 mt-6 md:pl-8" id="additionalContent">
          <!-- 阅读模块相关内容 -->
          <div class="mt-6 md:pl-8">
            <!-- 发布时间 -->
            <h4 class="text-base font-thin text-gray-700 mb-2">
              <i class="icon icon-release"></i>
              发布时间
            </h4>
            <div class="text-lg mb-6">2023-11-29</div>
            <!-- 标签 -->
            <h4 class="text-base font-thin text-gray-700 mb-2">
              <i class="icon icon-tag"></i>
              标签
            </h4>
            <div class="mb-6">
              <!-- 循环显示标签 -->
              
                <a href="https://shenshen6666.GitHub.io/tag/-r-4XTYN8/" class="py-1 px-4 border-gray-300 border text-sm inline-block text-gray-700 hover:text-gray-900 rounded mr-2 mb-2"># ES</a>
              
                <a href="https://shenshen6666.GitHub.io/tag/cBIbsZvpM/" class="py-1 px-4 border-gray-300 border text-sm inline-block text-gray-700 hover:text-gray-900 rounded mr-2 mb-2"># 转载</a>
              
            </div>
            <!-- 字数 -->
            <h4 class="text-base font-thin text-gray-700 mb-2">
              <i class="icon icon-words"></i>
              字数
            </h4>
            <div class="text-lg mb-6">7253 Char</div>
            <!-- 阅读时间 -->
            <h4 class="text-base font-thin text-gray-700 mb-2">
              <i class="icon icon-read"></i>
              阅读时间
            </h4>
            <div class="text-lg mb-6">31 min read</div>
            <!-- 阅读量 -->
            <h4 class="text-base font-thin text-gray-700 mb-2">
              <i class="icon icon-times"></i>
              阅读量
            </h4>
            <div class="text-lg mb-6"><span id="busuanzi_value_page_pv"></span> Times</div>
            <!-- 相关阅读 -->
            <h4 class="text-base font-thin text-gray-700 mb-2">
              <i class="icon icon-related"></i>
              相关阅读
            </h4>
            <div class="border-internal border-gray-400">
              

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
        
        <div class="border-internal border-gray-400 py-6">
          <a href="https://shenshen6666.GitHub.io/post/fen-bu-shi-sou-suo-yin-qing-03/" class="text-lg hover:text-red-600 my-2 inline-block post-list-title">
            
            分布式搜索引擎03
          </a>
        </div>
      
    
      
        
        <div class="border-internal border-gray-400 py-6">
          <a href="https://shenshen6666.GitHub.io/post/fen-bu-shi-sou-suo-yin-qing-03/" class="text-lg hover:text-red-600 my-2 inline-block post-list-title">
            
            分布式搜索引擎03
          </a>
        </div>
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  

  
    
      
    
      
    
  


            </div>
            <!-- 赞助内容 -->
            
  <h4 class="text-base font-thin text-gray-700 mb-2 mt-6">
    <i class="icon icon-sponsor"></i>
    赞赏
  </h4>
  <div class="post-sponsor text-gray-700">
    <img class="post-sponsor-img w-32 h-32 md:w-40 md:h-40" src="https://shenshen6666.GitHub.io\media\images\custom-weChatPayQR.png" alt="">
    <div>
      <i class="icon icon-wechat"></i>
      支付宝扫一扫领红包
    </div>
  </div>


          </div>
          <!-- 网址模块 -->
          <div class="zhihu-iframe mt-6">
            <!-- 添加网址模块地址的 iframe 代码 -->
            <iframe src="https://onehu.xyz/" width="100%" height="400px" frameborder="0" scrolling="yes"></iframe>
          </div>
          <!-- 切换按钮 -->
          <button id="toggleButton">切换</button>
          <!-- 上移按钮 -->
          <button id="moveUpButton">上</button>
          <!-- 下移按钮 -->
          <button id="moveDownButton">下</button>
        </div>
      </div>
      <!-- 页面底部内容 -->
      <!-- 其他内容省略 -->
      <div class="footer border-gray-400 border-external-top pt-6 mt-6 sm:mt-8 md:mt-10 mb-20 text-gray-700 text-sm sm:text-base lg:text-lg">
  Powered by <a href="https://github.com/shenshen6666/shenshen6666.GitHub.io" target="_blank">我的小屋</a>
</div>
    </div>
  </div>
  <!-- 页面脚本 -->
  <script>
    // 初始状态
    let isZhihuVisible = false;

    // 切换按钮点击事件
    $('#toggleButton').on('click', function() {
      $('.zhihu-iframe, #additionalContent .mt-6').toggle();
      // 这里可以添加其他模块的切换逻辑
    });

    // 上移按钮点击事件
    $('#moveUpButton').on('click', function() {
      let currentPosition = parseFloat($('.zhihu-iframe').css('top'));
      $('.zhihu-iframe').css('top', currentPosition - 10 + 'px');
    });

    // 下移按钮点击事件
    $('#moveDownButton').on('click', function() {
      let currentPosition = parseFloat($('.zhihu-iframe').css('top'));
      $('.zhihu-iframe').css('top', currentPosition + 10 + 'px');
    });

    // 代码高亮
    Prism.highlightAll();
  </script>
</body>
</html>
